
  import java.util.*;

    public class Main {

        /**
         * 返回两次操作后，数组元素之和的最小值
         * @param nums int整型一维数组 这你你需要操作的数组
         * @return long长整型
         */
        public long minimumValueAfterDispel (int[] nums) {
            // write code here
            /*
             * b×cnt[b,a)+a×cnt[a,a+b)+(a+b)×cnt[a+b,∞)
             * 跃阶函数
             */
            Arrays.sort(nums);
            long sum = 0;
            long max = 0;
            int len = nums.length;

            for(int j=0; j<len; j++){
                sum += nums[j];

                int index = j;
                int index2 = j;
                int index3 = j;
                //遍历
                for(int i=0; i<=j; i++){
                    //情况1，第一次是减去nums[j],第二次减去nums[i]. index返回的是最a+b 的元素位置
                    while(index < len && (long)nums[index] < (long)nums[i] + nums[j]) {
                        index++;
                    }
                    long tmp1 = (len-j)*(long)nums[j] + (len-index+j-i)*(long)nums[i];

                    //情况2，第一次是减去nums[i],第二次减去nums[j]-nums[i]， index2返回的是最靠近边界b的元素位置
                    while(index > 0 && nums[index2-1] >= nums[j] - nums[i]) {
                        index2--;
                    }
                    long tmp2 = (len-i)*(long)nums[i] + (len-j+i-index2)*((long)nums[j]-nums[i]);

                    //情况3，第一次是减去nums[j]-nums[i],第二次减去nums[j].
                    while(index3 > i && nums[index3-1] >= nums[j] - nums[i]){
                        index3--;
                    }
                    long tmp3 = (long)nums[i]*(index3 -i) + ((long)nums[j]-nums[i])*(j-index3) + (long)nums[j]*(len-j);

                    max = Math.max(max, tmp1);
                    max = Math.max(max, tmp2);
                    max = Math.max(max, tmp3);
                }
            }
            return sum - max;
  }
}




